import { DefaultObject, Utils } from "../utils";
import * as models from "../gen/finance/models";
import * as xml2json from 'xml2json';
import { parse as dateFnParseDate } from 'date-fns';
import { Deflate } from "zlib";
import { 
    BankTransaction, 
    BankTransactionTransactionTypeEnum, 
    BrokerageTransaction, 
    BrokerageTransactionTransactionTypeEnum,
    BrokerageTransactionStatusEnum, 
    Statement
} from "../gen/finance/models";
import { MerrillEdge } from "./MerrillEdge";
import * as nodeexpat from 'node-expat'

// Note: This should be autogenerated in future
let gOfxFidMap: DefaultObject = {
    "1001": "Capital One",
    "10898": "Chase",
    "3000": "Wells Fargo",
    "5959": "Bank of America"
}

export class OfxStatementExtractor
{
    private static timezoneRegExp = new RegExp(/\[([0-9-]+):([A-Z]+)\]/);
    private static brokerageTransKeys = [
        "BUYOPT",
        "SELLOPT",
        "BUYSTOCK",
        "SELLSTOCK"
    ]
    private static brokerageTransInvKeys = [
        "INVSELL",
        "INVBUY"
    ]
    private secIdMap:DefaultObject;

    private sgmlToXml(sgml: string)
    {
        sgml = sgml
            .replace(/>\s+</g, '><')    // remove whitespace in between tag close/open
            .replace(/\s+</g, '<')      // remove whitespace before a close tag
            .replace(/>\s+/g, '>')      // remove whitespace after a close tag
            //.replace(/<([A-Z0-9_]*)+\.+([A-Z0-9_]*)>([^<]+)/g, '<\$1\$2>\$3' )
            .replace(/<([\w\.]+)>([^<]+)<\/\1>/g, '<\$1>\$2' ) // remove close tags after values
            .replace(/<([\w\.]+)>([^<]+)/g, '<\$1>\$2</\$1>');
        return sgml;
    }

    private parseDate(datestr: string) {
        let m = datestr.search(OfxStatementExtractor.timezoneRegExp);
        if (m >= 0) { 
            datestr = datestr.slice(0,m);
        }

        if (datestr.indexOf(".") < 0) {
            return  dateFnParseDate(datestr, "yyyyMMddHHmmss", new Date());
        }
        else {
            return dateFnParseDate(datestr, "yyyyMMddHHmmss.SSS", new Date());
        }
    }

    private toBankTransaction(trans: any, currencyCode: string): BankTransaction {
        let desc = trans.NAME;
        if ("MEMO" in trans) {
            if (trans.MEMO != desc) {
                desc += trans.MEMO;
            }
        }

        return {
            postedDate: this.parseDate(trans.DTPOSTED),
            transactionDate: 'DTUSER' in trans ? this.parseDate(trans.DTUSER) : undefined,
            transactionType: (trans.TRNTYPE as string).indexOf("DEBIT") >= 0 ? models.BankTransactionTransactionTypeEnum.Debit : models.BankTransactionTransactionTypeEnum.Credit,
            amount: { currencyCode: currencyCode, value: Utils.normalizeNumberStringToNumber(trans.TRNAMT) },
            description: desc,
            transactionId: trans.FITID
        }
    }

    private toBrokerageTransaction(trans: any, currencyCode: string, key: string): BrokerageTransaction {
        let inv:any = null;
        OfxStatementExtractor.brokerageTransInvKeys.forEach(k => {
            if (k in trans) {
                inv = trans[k];
            }
        });

        if (inv == null) {
            throw "Invalid brokerage transaction";
        }

        let secId = inv.SECID.UNIQUEID;
        if (!(secId in this.secIdMap)) {
            throw `${secId} not found in mapping`;
        }
        let symbol = this.secIdMap[secId];
        // If custom option symbol for Merrill Edge, then convert to the OCC code
        if (inv.SECID.UNIQUEIDTYPE == "CUSTOM" && symbol.indexOf("#") >= 0) {
            symbol = MerrillEdge.symbolToOccCode(symbol);
        }

        return {
            tradeDate: this.parseDate(inv.INVTRAN.DTTRADE),
            settlementDate: this.parseDate(inv.INVTRAN.DTSETTLE),
            quantity: Utils.normalizeNumberStringToNumber(inv.UNITS),
            description: inv.INVTRAN.MEMO, 
            symbol: symbol,
            amount: {  currencyCode: currencyCode, value: Utils.normalizeNumberStringToNumber(inv.TOTAL) },
            price: {  currencyCode: currencyCode, value: Utils.normalizeNumberStringToNumber(inv.UNITPRICE) },
            commission: {  
                currencyCode: currencyCode, 
                value: Utils.normalizeNumberStringToNumber(inv.COMMISSION) + Utils.normalizeNumberStringToNumber(inv.FEES)
            },
            status: BrokerageTransactionStatusEnum.Settled,
            transactionType: key.indexOf("BUY") >= 0 ? BrokerageTransactionTransactionTypeEnum.Purchase : BrokerageTransactionTransactionTypeEnum.Sale
        }
    }

    private incomeToBankTransaction(trans: any, currencyCode: string): BankTransaction
    {
        return {
            postedDate: this.parseDate(trans.INVTRAN.DTTRADE),
            amount: { value: Utils.normalizeNumberStringToNumber(trans.TOTAL), currencyCode: currencyCode },
            description: trans.INVTRAN.MEMO,
            transactionType: BankTransactionTransactionTypeEnum.Credit
        }
    }

    private debugSgml(sgml: string)
    {
        console.log(sgml);
        let parser = new nodeexpat.Parser('UTF-8')

        parser.on('startElement', function (name, attrs) {
            console.log(`start ${name}`)
          })
        
          parser.on('endElement', function (name) {
            console.log(`end ${name}`)
          })
        
          parser.on('text', function (text) {
            console.log(`text ${text}`)
          })
        
          parser.on('error', function (error) {
            console.error(error)
          })

          parser.parse(sgml);
    }

    private toArray(obj: any): [any]
    {
        if (!Array.isArray(obj))
            return [obj];
        return obj as [any];
    }

    public process(ofxstr: string): models.Statement[]
    {
        let xml = `<OFX>${ofxstr.split('<OFX>', 2)[1]}`;

        let ret: models.Statement[] = []

        // Some XML statements are incorrectly indicated as SGML in the header, so inspecting the headers doesn't actually work.
        // First try to process as XML, and fallback to SGML
        let l:any;
        try {
            l = xml2json.toJson(xml, { 
                coerce: false, 
                arrayNotation: false,
                object: true
            });
        }
        catch (e) {
            let sgml = this.sgmlToXml(xml);
            
            try {
                l = xml2json.toJson(sgml, { 
                    coerce: false, 
                    arrayNotation: false,
                    object: true
                });
            }
            catch (e) {
                this.debugSgml(sgml);
                throw e;
            }
        }

        let ofx:any = l.OFX;

        let fid:string = ofx.SIGNONMSGSRSV1.SONRS.FI.FID;
        let institutionName:string = ofx.SIGNONMSGSRSV1.SONRS.FI.ORG;
        if (fid in gOfxFidMap) {
            institutionName = gOfxFidMap[fid];
        }

        if ("CREDITCARDMSGSRSV1" in ofx) {
            let ccStatement = ofx.CREDITCARDMSGSRSV1.CCSTMTTRNRS.CCSTMTRS;
            let currencyCode:string = ccStatement.CURDEF as string;
            let transactionObj:any = ccStatement.BANKTRANLIST;
            let statement: models.Statement = {
                accountNumber: ccStatement.CCACCTFROM.ACCTID,
                institutionName: institutionName,
                startDate: this.parseDate(transactionObj.DTSTART),
                endDate: this.parseDate(transactionObj.DTEND),
                creditCardTransactions: []
            }

            if (transactionObj) {
                this.toArray(transactionObj.STMTTRN).forEach((trans:any) => {
                    statement.creditCardTransactions.push(this.toBankTransaction(trans, currencyCode))
                });
            }

            ret.push(statement);
        }
        if ("BANKMSGSRSV1" in ofx) {
            let ofxStatement = ofx.BANKMSGSRSV1.STMTTRNRS.STMTRS;
            let currencyCode:string = ofxStatement.CURDEF as string;
            let transactionObj:any = ofxStatement.BANKTRANLIST;

            let statement: models.Statement = {
                accountNumber: ofxStatement.BANKACCTFROM.ACCTID,
                institutionName: institutionName,
                startDate: this.parseDate(transactionObj.DTSTART),
                endDate: this.parseDate(transactionObj.DTEND),
                bankTransactions: []
            }

            transactionObj.STMTTRN.forEach((trans:any) => {
                statement.bankTransactions.push(this.toBankTransaction(trans, currencyCode))
            });

            ret.push(statement);
        }
        if ("SECLISTMSGSRSV1" in ofx) {
            let secList = ofx.SECLISTMSGSRSV1.SECLIST;
            this.secIdMap = {};
            [ "OPTINFO", "STOCKINFO" ].forEach(k => {
                if (k in secList) {
                    let optInfo:[any] = this.toArray(secList[k]);
                    optInfo.forEach(e => {
                        this.secIdMap[e.SECINFO.SECID.UNIQUEID] = e.SECINFO.TICKER;
                    });
                }
            });
        }
        if ("INVSTMTMSGSRSV1" in ofx) {
            let stmtrans:[any] = this.toArray(ofx.INVSTMTMSGSRSV1.INVSTMTTRNRS);
            stmtrans.forEach(account => {
                account = account.INVSTMTRS;
                let currencyCode:string = account.CURDEF as string;
                let transactionObj:any = account.INVTRANLIST;
                if (transactionObj) {
                    let statement: models.Statement = {
                        accountNumber: account.INVACCTFROM.ACCTID,
                        institutionName: institutionName,
                        startDate: this.parseDate(transactionObj.DTSTART),
                        endDate: this.parseDate(transactionObj.DTEND),
                        brokerageTransactions: [],
                        bankTransactions: []
                    }

                    OfxStatementExtractor.brokerageTransKeys.forEach(k => {
                        if (k in transactionObj) {
                            let trans:[any] = this.toArray(transactionObj[k]);
                            trans.forEach(t => { statement.brokerageTransactions.push(this.toBrokerageTransaction(t, currencyCode, k)); });
                        }    
                    });

                    // dividends
                    if ("INCOME" in transactionObj) {
                        let trans:[any] = this.toArray(transactionObj["INCOME"]);
                        trans.forEach(t => statement.bankTransactions.push(this.incomeToBankTransaction(t, currencyCode)));
                    }

                    statement.brokerageTransactions.sort((a, b) => {
                        return a.tradeDate.getTime() - b.tradeDate.getTime();
                    });

                    ret.push(statement);
                }
            });
        }

        return ret;
    }
}
